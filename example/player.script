local client = require("example.client")

go.property("local_player", true)
go.property("player_nr", 0)

local GRAVITY = -1
local MOVEMENT_SPEED = 5
local ROTATION_SPEED = 2
local JUMP_SPEED = 20

local ANIM_IDLE = "Idle"
local ANIM_WALK = "Walking_A"
local ANIM_ATTACK = "1H_Melee_Attack_Chop"
local ANIM_JUMP_START = "Jump_Start"

local MSG_POS = "pos"
local MSG_TURN = "turn"
local MSG_MOVE = "move"
local MSG_ATTACK = "attack"
local MSG_JUMP = "jump"

local ACTION_LEFT = hash("left")
local ACTION_RIGHT = hash("right")
local ACTION_FORWARD = hash("forward")
local ACTION_BACK = hash("back")
local ACTION_JUMP = hash("jump")
local ACTION_ATTACK = hash("attack")

local MSG_CONTACT_POINT_RESPONSE = hash("contact_point_response")

local FORWARD_VECTOR = vmath.vector3(0, 0, 1)

local function play_animation(self, id, playback)
	if self.animation ~= id then
		local previous = self.animation
		local previous_playback = self.animation_playback
		self.animation = id
		self.animation_playback = playback
		model.play_anim("model#model", id, playback or go.PLAYBACK_LOOP_FORWARD, nil, function()
			self.animation = previous
			model.play_anim("model#model", previous, previous_playback or go.PLAYBACK_LOOP_FORWARD)
		end)
	end
end

local function turn(self, value)
	self.rotation = value
	if self.local_player and self.room then
		self.room:send(MSG_TURN, { value = value })
	end
end

local function move(self, value)
	if value == 0 then
		play_animation(self, ANIM_IDLE)
	else
		play_animation(self, ANIM_WALK)
	end
	self.forward = value
	if self.local_player and self.room then
		self.room:send(MSG_MOVE, { forward = value })
	end
end

local function attack(self)
	play_animation(self, ANIM_ATTACK, go.PLAYBACK_ONCE_FORWARD)
	if self.local_player and self.room then
		self.room:send(MSG_ATTACK, {})
	end
end

local function jump(self, speed)
	self.velocity.y = speed
	self.ground_contact = false
	play_animation(self, ANIM_JUMP_START, go.PLAYBACK_ONCE_FORWARD)
	if self.local_player and self.room then
		self.room:send(MSG_JUMP, { speed = speed })
	end
end

local function handle_event(self, event_type, data)
	if event_type == MSG_POS then
		-- Defer engine calls to update for remote players
		self.next_pos = vmath.vector3(data.x, data.y, data.z)
		self.next_eulerY = data.eulerY
	elseif event_type == MSG_MOVE then
		-- Update desired forward; animation handled in update
		self.forward = data.forward
	elseif event_type == MSG_TURN then
		-- Update desired rotation value; applied in update
		self.rotation = data.value
	elseif event_type == MSG_ATTACK then
		self.pending_attack = true
	elseif event_type == MSG_JUMP then
		self.pending_jump_speed = data.speed or 0
	end
end


function init(self)
	-- rotation around the y-axis
	-- positive value = rotate clockwise, negative value = rotate counter clockwise,
	self.rotation = 0

	-- movement in direction
	-- positive value = move forward, negative value = move backwards
	self.forward = 0

	self.velocity = vmath.vector3()

	-- for resolving physics collisions
	self.correction = vmath.vector3()

	-- currently played animation
	self.animation = nil

	play_animation(self, ANIM_IDLE)

	-- enabled and disable meshes to get the correct look
	-- weapons
	model.set_mesh_enabled("model#model", "1H_Sword", true)
	model.set_mesh_enabled("model#model", "1H_Sword_Offhand", false)
	model.set_mesh_enabled("model#model", "2H_Sword", false)

	-- equipment
	model.set_mesh_enabled("model#model", "Knight_Helmet", false)
	model.set_mesh_enabled("model#model", "Knight_Cape", false)

	-- different shields
	model.set_mesh_enabled("model#model", "Spike_Shield", true)
	model.set_mesh_enabled("model#model", "Round_Shield", false)
	model.set_mesh_enabled("model#model", "Rectangle_Shield", false)
	model.set_mesh_enabled("model#model", "Badge_Shield", false)

	self.room = client.get_room()

	if self.local_player then
		msg.post(".", "acquire_input_focus")
		local target = msg.url(msg.url().socket, "/game", "game")
		msg.post(target, "attach_camera", { player_id = go.get_id() })
	else
		-- Remote player will receive network updates via local messages from game.script
	end
end

function final(self)
	if self.local_player then
		-- no timer to cancel
	end
end

function update(self, dt)
	-- Local player: emit position every frame (small payload)
	if self.local_player and self.room then
		local pos = go.get_position()
		self.room:send(MSG_POS, {
			x = pos.x,
			y = pos.y,
			z = pos.z,
			eulerY = go.get("model", "euler.y"),
		})
	end

	-- Remote players: apply buffered state and exit
	if not self.local_player then
		if self.next_pos then
			go.set_position(self.next_pos)
			self.ground_contact = true
			self.next_pos = nil
		end
		if self.next_eulerY ~= nil then
			go.set("model", "euler.y", self.next_eulerY)
			self.next_eulerY = nil
		end
		-- Update animation based on forwarded movement intent
		if self.previous_forward ~= self.forward then
			if self.forward == 0 then
				play_animation(self, ANIM_IDLE)
			else
				play_animation(self, ANIM_WALK)
			end
			self.previous_forward = self.forward
		end
		if self.pending_attack then
			play_animation(self, ANIM_ATTACK, go.PLAYBACK_ONCE_FORWARD)
			self.pending_attack = nil
		end
		if self.pending_jump_speed then
			play_animation(self, ANIM_JUMP_START, go.PLAYBACK_ONCE_FORWARD)
			self.pending_jump_speed = nil
		end
		return
	end

	-- rotate model object around the y-axis
	local rot = go.get_rotation("model")
	rot = rot * vmath.quat_rotation_y(ROTATION_SPEED * -self.rotation * dt)
	go.set_rotation(rot, "model")

	-- move in direction of facing
	local dir = vmath.rotate(rot, FORWARD_VECTOR * self.forward * MOVEMENT_SPEED)

	-- set velocity along the flow based on movement direction
	-- also add gravity if in the air
	self.velocity.x = dir.x
	self.velocity.z = dir.z
	if not self.ground_contact then
		self.velocity.y = self.velocity.y + GRAVITY
	end

	-- update position
	local pos = go.get_position()
	pos = pos + self.velocity * dt
	go.set_position(pos)

	-- reset volatile variables
	self.correction = vmath.vector3()
	self.ground_contact = false
end

function on_message(self, message_id, message, sender)
	if message_id == MSG_CONTACT_POINT_RESPONSE then
		-- https://defold.com/manuals/physics-resolving-collisions/
		if message.distance > 0 then
			local proj = vmath.project(self.correction, message.normal * message.distance)
			if proj < 1 then
				local comp = (message.distance - message.distance * proj) * message.normal
				go.set_position(go.get_position() + comp)
				self.correction = self.correction + comp
			end
		end
		-- check for ground contact
		-- clear vertical velocity if falling
		if message.other_group == hash("floor") then
			if self.velocity.y <= 0 then
				self.velocity.y = 0
				self.ground_contact = true
			end
		end
		return
	end

	if message_id == hash("net_pos") then
		handle_event(self, MSG_POS, message)
	elseif message_id == hash("net_turn") then
		handle_event(self, MSG_TURN, message)
	elseif message_id == hash("net_move") then
		handle_event(self, MSG_MOVE, message)
	elseif message_id == hash("net_attack") then
		handle_event(self, MSG_ATTACK, message)
	elseif message_id == hash("net_jump") then
		handle_event(self, MSG_JUMP, message)
	end
end

function on_input(self, action_id, action)
	if action_id == ACTION_LEFT then
		if action.pressed then
			turn(self, -1)
		elseif action.released then
			turn(self, 0)
		end
	elseif action_id == ACTION_RIGHT then
		if action.pressed then
			turn(self, 1)
		elseif action.released then
			turn(self, 0)
		end
	elseif action_id == ACTION_FORWARD then
		if action.pressed then
			move(self, 1)
		elseif action.released then
			move(self, 0)
		end
	elseif action_id == ACTION_BACK then
		if action.pressed then
			move(self, -1)
		elseif action.released then
			move(self, 0)
		end
	elseif action_id == ACTION_ATTACK then
		if action.pressed then
			attack(self)
		end
	elseif action_id == ACTION_JUMP then
		if action.pressed then
			jump(self, JUMP_SPEED)
		end
	end
end
